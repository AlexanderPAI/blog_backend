# Тестовое задание: rest api для Блога.

https://wiki.nekidaem.ru/s/test-rest-api-python

# Соискатель

Петров Александр Иванович

Ссылка на резюме: https://hh.ru/resume/3c099319ff0c68c07f0039ed1f7a524841447a

# Основной стек:

- Django 4.2.9
- Django REST Framework 3.14.0
- Gunicorn 21.2.0
- Psycopg2-binary 2.9.9
- Celery 5.3.6
- Redis 5.0.1
- Factoryboy 3.3.0 (для генерации тестовых данных в БД)

# Описание

В приложении реализованы эндпоинты:

- `http://127.0.0.1/api/v1/posts/` - создание поста, получение списка всех постов
- `http://127.0.0.1/api/v1/posts/{id}` - получение поста по `id`, обновление, удаление
- `http://127.0.0.1/api/v1/posts/{id}/is_read/` - отметить соответствующий пост прочитанным (`POST`-запрос - установить статус прочитано, `DELETE`-запрос - убрать статус прочитано)
- `http://127.0.0.1/api/v1/follows/` - создание подписки, получение списка всех подписок
- `http://127.0.0.1/api/v1/follows/{id}` - получение подписки по `id`, обновление, удаление
- `http://127.0.0.1/api/v1/feed/` - лента пользователя - посты авторов, на которых подписан пользователь, с пагинацией по 10 постов на странице.

Аутентификация DRF реализована через BasicAuthentification, так как в ТЗ нет вводных по необходимому способу аутентификации.
При этом лучше было бы сделать через JWT.

Один раз в сутки приложение собирает данные о последних 5 постах ленты каждого пользователя и рассылает письма с ними.
Отправка письма эмулируется через консоль (в консоль выводятся все письма).
Для демонстрации можно изменить период рассылки на меньший:
В `blog_backend/src/celery_app.py`:
```python
app.conf.beat_schedule = {
    'every': {
        'task': 'posts.tasks.repeat_send_mail',
        'schedule': crontab(minute='0', hour=0) 
        # заменить на сrontab(minute='*/2') - так рассылка 
        # будет осуществляться каждые две минуты.
    },
}
```

Реализована возможность генерации тестовых данных в БД для тестирования (см инструкцию по запуску ниже).

Покрыть приложение тестами за такой короткий срок (2 дня), к сожалению не успел.
Было бы чуть побольше времени - безусловно, сделал бы.

# Запуск приложения:
#### 1. Клонировать репозиторий:
```bash
git clone git@github.com:AlexanderPAI/blog_backend.git
```

#### 2. Скачать тестовый `.env`-файл [отсюда](https://disk.yandex.ru/d/75EC23eDMHCO7w) и расположить в каталоге `blog_backend/src/blog/`
SECRET_KEY Django, данные БД PostgreSQL спрятаны через dotenv в переменные окружения.
Без `.env`-файла приложение работать не будет.

#### 3. Из каталога приложения собрать докер-образы и запустить приложение через docker-compose:
```bash
cd blog_backend
docker-compose build
# Без флага -d так в консоль будет выводиться рассылка писем.
docker-compose up
```

#### 4. Открыть второй терминал (при запущенном приложении через docker-compose) и в контейнере `blog_backend` сгенерировать тестовые данные в БД, а также создать суперпользователя:
```bash
docker-compose run --rm blog_backend sh -c "python ./src/manage.py generate_test_data && python ./src/manage.py createsuperuser"
```

PS: Делать миграции через терминал контейнера `blog_backend` не нужно, применение миграций осуществляется автоматически при каждом перезапуске контейнера (указано в docker-compose.yaml)

#### 5. Эндпоинты приложения доступны по url:
`http://127.0.0.1/api/v1/` (**без указания порта** так как настроена маршрутизация через `nginx`)
